# 多生产者单消费者环形队列的设计

## 普通环形队列概述
将一个普通队列的头尾相连就形成了一个环形队列。
![此处输入图片的描述][1]
可参考[此文][2]。
环形队列一般有一个读指针和一个写指针，分别负责读写队列中每个区块的内容。当读指针和写指针指向同一区块时队列为空，当读指针在写指针后面一个区块的时候队列为满。

## 多生产者单消费者环形队列设计
多生产者单消费者环形队列支持在同一时间内有多个写线程和一个读线程同时的读写操作，需要考虑并发问题。

## 队列区块
### 成员
队列中的每个区块都由两部分组成：

 - 存储的内容
 - 一把读锁

读锁用于提示读线程该区块是否已经被写线程完成写入工作，以避免写线程写到一半读线程就开始读该区块，因为写入过程可能会很长。
### 读锁作用
 - 当读锁处于锁住状态，意为该区块为空或该区块没有完成写入，读线程不能读取该区块的内容。
 - 当读锁处于释放状态，意为写线程已完成对该区块的写入工作，读线程可以读取该区块内容。

## 队列
### 成员
整个环形队列由以下成员构成：

 - 队列容量C：静态定量，设为2的整数次方，原因之后会讲
 - 队列本体：由队列区块构成的数组
 - 一个读指针：指向读线程即将读取的区块序号
 - 一个写指针：指向下一个可以被写线程申请的区块的序号
 - 一把写锁：用于处理多个写线程同时申请写队列的情况

### 方法
 - 初始化
 - 申请写区块
 - 写队列
 - 读队列

### 工作过程
#### 初始化
所有区块的读锁全部设为锁住状态，意为所有区块都不可读，因为所有区块都是空的。读写指针分别设为0。

#### 读线程启动
初始化后队列唯一的一个读线程启动。读线程的工作过程如下：

 1. 对区块的读锁进行上锁操作。
 若阻塞则说明该区块不可读，可能情况有两种：该区块为空，写线程没有写入完成。一旦写线程写入完成后解锁读锁，阻塞情况便消失。
 2. 读取内容
 3. 移动读指针到下一区块

#### 多线程写入
当多个写线程要向环形队列写入内容时，需要经历以下步骤。

1. 申请写区块
首先向队列发出写入申请，调用队列中“申请写区块”的方法。此时对队列写锁进行锁住操作。若阻塞则说明此时已经有其它写线程正在申请写区块，故阻塞。若未阻塞，说明没有并发发生，则锁住队列写锁，开始队列的判满逻辑。若队列满，则返回-1，申请写区块失败。若队列未满，则返回当前写指针所指的区块序号，并将写指针移动至下一区块，最后解锁队列的写锁。

 - 环形队列中的指针移动下一区块的公式为：
$$ p_{n+1} = ( p_n + 1 )  \%  C $$
但取余操作对于CPU来说是一个较为耗时的过程，所以进行优化为：
$$ p_{n+1} = ( p_n +1 ) \& ( C - 1 ) , C = 2 ^ n $$
实验已证明，优化后的与操作要比取余操作效率更高，但要求C为2的整数次方。

 - 队列判满逻辑
当读指针超前写指针1个区块的时候队列为满。这样设计的原因是区分队列空的状态（读指针和写指针指向同一区块），并且避免读指针和写指针同时读写同一区块的现象发生。

2. 写入区块
当写线程成功申请到队列位置后，便开始写入内容的操作。当写入操作结束后，写线程解锁该区块的读锁，意为告诉读线程此区块已完成写入，可以读取。

## 写入失败队列永久阻塞的问题与解决
### 问题描述
当一个写线程的解锁读锁操作终未执行或者执行失败的后，读线程只会永久阻塞在该区块终，认为该区块不可读取，没有响应解决措施。
### 解决办法
对读线程，用pthread_mutex_trylock替代原来的pthread_mutex_lock。phtread_mutex_lock函数在对已上锁的锁进行上锁操作的时候会阻塞等待直到锁释放。但phtread_mutex_trylock函数在对已上锁的锁进行上锁操作时候会立即返回值。
当第一次上锁失败后，探测该区块后5个区块位置的锁。若有已解锁读锁的区块，则读指针直接跳到该区块开始读取工作，不对原区块进行额外操作。





  [1]: http://hi.csdn.net/attachment/201107/9/0_1310174978ngyt.gif
  [2]: http://blog.csdn.net/sking002007/article/details/6584590